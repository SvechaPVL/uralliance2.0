---
description: Создать или обновить спецификацию функции из описания функции на естественном языке.
---

## Ввод пользователя

```text
$ARGUMENTS
```

Вы **ДОЛЖНЫ** учесть ввод пользователя перед продолжением (если он не пустой).

## Структура

Текст, который пользователь ввел после `/speckit.specify` в сообщении запуска **является** описанием функции. Предполагайте, что он всегда доступен в этом разговоре, даже если `$ARGUMENTS` появляется буквально ниже. Не просите пользователя повторить его, если только он не предоставил пустую команду.

Получив это описание функции, сделайте следующее:

1. **Сгенерируйте краткое короткое имя** (2-4 слова) для ветки:
   - Проанализируйте описание функции и извлеките наиболее значимые ключевые слова
   - Создайте короткое имя из 2-4 слов, которое передает суть функции
   - По возможности используйте формат действие-существительное (например, "add-user-auth", "fix-payment-bug")
   - Сохраняйте технические термины и акронимы (OAuth2, API, JWT и т.д.)
   - Сделайте его кратким, но достаточно описательным, чтобы понять функцию с первого взгляда
   - Примеры:
     - "Я хочу добавить аутентификацию пользователей" → "user-auth"
     - "Реализовать интеграцию OAuth2 для API" → "oauth2-api-integration"
     - "Создать дашборд для аналитики" → "analytics-dashboard"
     - "Исправить баг тайм-аута обработки платежей" → "fix-payment-timeout"

2. **Проверьте существующие ветки перед созданием новой**:

   a. Сначала получите все удаленные ветки, чтобы убедиться, что у нас есть последняя информация:

   ```bash
   git fetch --all --prune
   ```

   b. Найдите наивысший номер функции по всем источникам для короткого имени:
   - Удаленные ветки: `git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`
   - Локальные ветки: `git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`
   - Директории спецификаций: Проверьте директории, соответствующие `specs/[0-9]+-<short-name>`

   c. Определите следующий доступный номер:
   - Извлеките все номера из всех трех источников
   - Найдите наивысший номер N
   - Используйте N+1 для нового номера ветки

   d. Запустите скрипт `.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS"` с вычисленным номером и коротким именем:
   - Передайте `--number N+1` и `--short-name "ваше-короткое-имя"` вместе с описанием функции
   - Пример для Bash: `.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS" --json --number 5 --short-name "user-auth" "Add user authentication"`
   - Пример для PowerShell: `.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS" -Json -Number 5 -ShortName "user-auth" "Add user authentication"`

   **ВАЖНО**:
   - Проверьте все три источника (удаленные ветки, локальные ветки, директории спецификаций), чтобы найти наивысший номер
   - Сопоставляйте только ветки/директории с точным паттерном короткого имени
   - Если не найдено существующих веток/директорий с этим коротким именем, начните с номера 1
   - Вы должны запускать этот скрипт только один раз для каждой функции
   - JSON предоставляется в терминале в качестве вывода - всегда обращайтесь к нему, чтобы получить фактическое содержимое, которое вы ищете
   - Вывод JSON будет содержать пути BRANCH_NAME и SPEC_FILE
   - Для одинарных кавычек в аргументах типа "I'm Groot" используйте синтаксис экранирования: например 'I'\''m Groot' (или двойные кавычки, если возможно: "I'm Groot")

3. Загрузите `.specify/templates/spec-template.md`, чтобы понять требуемые разделы.

4. Следуйте этому потоку выполнения:
   1. Разберите описание пользователя из ввода
      Если пусто: ERROR "Не предоставлено описание функции"
   2. Извлеките ключевые концепции из описания
      Определите: актеры, действия, данные, ограничения
   3. Для неясных аспектов:
      - Делайте обоснованные предположения на основе контекста и отраслевых стандартов
      - Отмечайте [NEEDS CLARIFICATION: конкретный вопрос] только если:
        - Выбор значительно влияет на область функции или пользовательский опыт
        - Существует несколько разумных интерпретаций с разными последствиями
        - Не существует разумного значения по умолчанию
      - **ОГРАНИЧЕНИЕ: Максимум 3 маркера [NEEDS CLARIFICATION] всего**
      - Приоритизируйте уточнения по влиянию: область > безопасность/конфиденциальность > пользовательский опыт > технические детали
   4. Заполните раздел пользовательских сценариев и тестирования
      Если нет четкого пользовательского потока: ERROR "Невозможно определить пользовательские сценарии"
   5. Сгенерируйте функциональные требования
      Каждое требование должно быть тестируемым
      Используйте разумные значения по умолчанию для неуказанных деталей (документируйте предположения в разделе Предположения)
   6. Определите критерии успеха
      Создайте измеримые, технологически независимые результаты
      Включите как количественные метрики (время, производительность, объем), так и качественные меры (удовлетворенность пользователей, завершение задач)
      Каждый критерий должен быть проверяемым без деталей реализации
   7. Определите ключевые сущности (если задействованы данные)
   8. Верните: SUCCESS (спецификация готова к планированию)

5. Запишите спецификацию в SPEC_FILE, используя структуру шаблона, заменяя плейсхолдеры конкретными деталями, полученными из описания функции (аргументы), сохраняя порядок разделов и заголовки.

6. **Валидация качества спецификации**: После написания начальной спецификации проверьте ее на соответствие критериям качества:

   a. **Создайте чеклист качества спецификации**: Сгенерируйте файл чеклиста в `FEATURE_DIR/checklists/requirements.md`, используя структуру шаблона чеклиста с этими пунктами валидации:

   ```markdown
   # Чеклист качества спецификации: [ИМЯ ФУНКЦИИ]

   **Цель**: Проверка полноты и качества спецификации перед планированием
   **Создано**: [ДАТА]
   **Функция**: [Ссылка на spec.md]

   ## Качество содержимого

   - [ ] Нет деталей реализации (языки, фреймворки, API)
   - [ ] Сосредоточено на пользовательской ценности и бизнес-потребностях
   - [ ] Написано для нетехнических заинтересованных сторон
   - [ ] Все обязательные разделы заполнены

   ## Полнота требований

   - [ ] Не осталось маркеров [NEEDS CLARIFICATION]
   - [ ] Требования тестируемы и однозначны
   - [ ] Критерии успеха измеримы
   - [ ] Критерии успеха технологически независимы (нет деталей реализации)
   - [ ] Все сценарии приемки определены
   - [ ] Граничные случаи идентифицированы
   - [ ] Область четко ограничена
   - [ ] Зависимости и предположения идентифицированы

   ## Готовность функции

   - [ ] Все функциональные требования имеют четкие критерии приемки
   - [ ] Пользовательские сценарии покрывают основные потоки
   - [ ] Функция соответствует измеримым результатам, определенным в критериях успеха
   - [ ] Детали реализации не проникают в спецификацию

   ## Примечания

   - Элементы, отмеченные как незавершенные, требуют обновления спецификации перед `/speckit.clarify` или `/speckit.plan`
   ```

   b. **Запустите проверку валидации**: Проверьте спецификацию по каждому пункту чеклиста:
   - Для каждого пункта определите, проходит он проверку или нет
   - Задокументируйте обнаруженные проблемы (процитируйте соответствующие разделы спецификации)

   c. **Обработайте результаты валидации**:
   - **Если все пункты пройдены**: Отметьте чеклист как завершенный и переходите к шагу 7

   - **Если пункты не прошли (исключая [NEEDS CLARIFICATION])**:
     1. Перечислите непройденные пункты и конкретные проблемы
     2. Обновите спецификацию для устранения каждой проблемы
     3. Повторите валидацию, пока все пункты не будут пройдены (максимум 3 итерации)
     4. Если все еще не проходит после 3 итераций, задокументируйте оставшиеся проблемы в примечаниях чеклиста и предупредите пользователя

   - **Если остались маркеры [NEEDS CLARIFICATION]**:
     1. Извлеките все маркеры [NEEDS CLARIFICATION: ...] из спецификации
     2. **ПРОВЕРКА ЛИМИТА**: Если существует более 3 маркеров, оставьте только 3 наиболее критичных (по влиянию на область/безопасность/UX) и сделайте обоснованные предположения для остальных
     3. Для каждого необходимого уточнения (максимум 3) представьте опции пользователю в этом формате:

        ```markdown
        ## Вопрос [N]: [Тема]

        **Контекст**: [Процитируйте соответствующий раздел спецификации]

        **Что нам нужно узнать**: [Конкретный вопрос из маркера NEEDS CLARIFICATION]

        **Предлагаемые ответы**:

        | Опция | Ответ                       | Последствия                                         |
        | ----- | --------------------------- | --------------------------------------------------- |
        | A     | [Первый предлагаемый ответ] | [Что это означает для функции]                      |
        | B     | [Второй предлагаемый ответ] | [Что это означает для функции]                      |
        | C     | [Третий предлагаемый ответ] | [Что это означает для функции]                      |
        | Свой  | Предоставьте свой ответ     | [Объясните, как предоставить пользовательский ввод] |

        **Ваш выбор**: _[Ожидайте ответа пользователя]_
        ```

     4. **КРИТИЧНО - Форматирование таблиц**: Убедитесь, что таблицы markdown правильно отформатированы:
        - Используйте согласованные пробелы с выровненными вертикальными чертами
        - Каждая ячейка должна иметь пробелы вокруг содержимого: `| Содержимое |`, а не `|Содержимое|`
        - Разделитель заголовка должен иметь не менее 3 тире: `|--------|`
        - Проверьте, что таблица корректно отображается в предпросмотре markdown
     5. Нумеруйте вопросы последовательно (В1, В2, В3 - максимум 3 всего)
     6. Представьте все вопросы вместе перед ожиданием ответов
     7. Дождитесь ответа пользователя с их выбором для всех вопросов (например, "В1: A, В2: Свой - [детали], В3: B")
     8. Обновите спецификацию, заменив каждый маркер [NEEDS CLARIFICATION] выбранным или предоставленным пользователем ответом
     9. Повторите валидацию после того, как все уточнения будут разрешены

   d. **Обновите чеклист**: После каждой итерации валидации обновляйте файл чеклиста текущим статусом пройдено/не пройдено

7. Сообщите о завершении с именем ветки, путем к файлу спецификации, результатами чеклиста и готовностью к следующей фазе (`/speckit.clarify` или `/speckit.plan`).

**ПРИМЕЧАНИЕ:** Скрипт создает и переключается на новую ветку и инициализирует файл спецификации перед записью.

## Общие рекомендации

## Быстрые рекомендации

- Сосредоточьтесь на **ЧТО** нужно пользователям и **ПОЧЕМУ**.
- Избегайте КАК реализовать (никакого технологического стека, API, структуры кода).
- Написано для бизнес-заинтересованных сторон, а не разработчиков.
- НЕ создавайте никаких чеклистов, встроенных в спецификацию. Это будет отдельная команда.

### Требования к разделам

- **Обязательные разделы**: Должны быть заполнены для каждой функции
- **Необязательные разделы**: Включайте только тогда, когда они имеют отношение к функции
- Когда раздел неприменим, удалите его полностью (не оставляйте как "Н/Д")

### Для AI генерации

При создании этой спецификации из запроса пользователя:

1. **Делайте обоснованные предположения**: Используйте контекст, отраслевые стандарты и распространенные паттерны для заполнения пробелов
2. **Документируйте предположения**: Записывайте разумные значения по умолчанию в разделе Предположения
3. **Ограничивайте уточнения**: Максимум 3 маркера [NEEDS CLARIFICATION] - используйте только для критических решений, которые:
   - Значительно влияют на область функции или пользовательский опыт
   - Имеют несколько разумных интерпретаций с разными последствиями
   - Не имеют разумного значения по умолчанию
4. **Приоритизируйте уточнения**: область > безопасность/конфиденциальность > пользовательский опыт > технические детали
5. **Думайте как тестировщик**: Каждое нечеткое требование должно провалить пункт чеклиста "тестируемое и однозначное"
6. **Общие области, требующие уточнения** (только если не существует разумного значения по умолчанию):
   - Область и границы функции (включение/исключение конкретных случаев использования)
   - Типы пользователей и разрешения (если возможны множественные конфликтующие интерпретации)
   - Требования безопасности/соответствия (когда юридически/финансово значимы)

**Примеры разумных значений по умолчанию** (не спрашивайте об этом):

- Хранение данных: Отраслевые стандарты для домена
- Цели производительности: Стандартные ожидания веб/мобильных приложений, если не указано иное
- Обработка ошибок: Понятные пользователю сообщения с соответствующими резервными вариантами
- Метод аутентификации: Стандартная на основе сессий или OAuth2 для веб-приложений
- Паттерны интеграции: RESTful API, если не указано иное

### Руководство по критериям успеха

Критерии успеха должны быть:

1. **Измеримыми**: Включать конкретные метрики (время, процент, количество, скорость)
2. **Технологически независимыми**: Никаких упоминаний фреймворков, языков, баз данных или инструментов
3. **Ориентированными на пользователя**: Описывать результаты с точки зрения пользователя/бизнеса, а не внутренних систем
4. **Проверяемыми**: Можно тестировать/проверять без знания деталей реализации

**Хорошие примеры**:

- "Пользователи могут завершить оформление заказа менее чем за 3 минуты"
- "Система поддерживает 10 000 одновременных пользователей"
- "95% поисковых запросов возвращают результаты менее чем за 1 секунду"
- "Уровень завершения задач улучшается на 40%"

**Плохие примеры** (ориентированные на реализацию):

- "Время ответа API менее 200 мс" (слишком технично, используйте "Пользователи видят результаты мгновенно")
- "База данных может обрабатывать 1000 TPS" (деталь реализации, используйте пользовательскую метрику)
- "React компоненты рендерятся эффективно" (специфично для фреймворка)
- "Уровень попаданий в кэш Redis выше 80%" (специфично для технологии)
